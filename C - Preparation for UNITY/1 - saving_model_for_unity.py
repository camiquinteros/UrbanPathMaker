# -*- coding: utf-8 -*-
"""Saving Model for UNITY

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rg_Y1HjKBthzlb61X-p-QzTRCS_W9Uuh
"""

# Import standard Libraries
import pandas as pd
import seaborn as sns
import altair as alt
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2
import numpy as np


sns.set(rc={'figure.figsize':(10,10)})
print("imports ok")

from google.colab import drive
drive.mount('/content/gdrive')

"""#ANN Regresion Training

"""

data = pd.read_csv('/content/gdrive/MyDrive/00.Module 3 - Group 2/Studio/DATASETS/Predicting_Pedestrian_data_using_urbano/1to100combo_2yrs_2seasons.csv')
pd.options.display.max_columns = None

print(data.head)

print(data.info())

for colname, col in data.iteritems():
  print(colname, "min_val", col.min(), "max_val", col.max())

data1 = data.iloc[:,1:]

print(data1.info())

X = data.iloc[:,3:9]
print(X.info())

# Load and instantiate a StandardSclaer 
from sklearn.preprocessing import StandardScaler
scalerX = StandardScaler()

# Apply the scaler to our X-features
X_scaled = scalerX.fit_transform(X)

print(X_scaled)

print(scalerX)

print(X_scaled[114,:])

print(type(X_scaled))



#declare regression target
y = data.loc[:,"pedestrian_total"].to_numpy()


y = y.reshape(-1, 1)

from sklearn.preprocessing import MinMaxScaler
scalerY = MinMaxScaler()


#In this case it makes sense to use MinMax scaling because the wage seems like a relative range
# Apply the scaler to our Y-features
y_scaled = scalerY.fit_transform(y)

print(y_scaled)

#scaling to pickle
from sklearn.externals import joblib
scalerX_filename = "scalerX1.save"
joblib.dump(scalerX, scalerX_filename)

scalerY_filename = "scalerY1.save"
joblib.dump(scalerY, scalerY_filename)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size = 0.2, random_state = 47)

print("TRAIN", "input", X_train.shape, "output", y_train.shape)
print("TEST", "input", X_test.shape, "output", y_test.shape)
print(type(X_train[0:0]))

# Instantiate a sequential model
model = tf.keras.models.Sequential()
n_cols = X_scaled.shape[1]  

# Add 2 dense layers of 50 and 32 neurons each
model.add(tf.keras.layers.Dense(128, input_shape=(n_cols,), activation='relu'))
model.add(tf.keras.layers.Dense(64, activation='relu'))
  
# Add a dense layer with 1 value output
model.add(tf.keras.layers.Dense(1, activation= "sigmoid"))
  
# Compile your model 
model.compile(optimizer = "adam", loss = "mean_squared_error")

model.summary()

import os
import os.path as path

checkpoint_path = "/content/gdrive/MyDrive/Studio/cp.ckpt"
checkpoint_dir = os.path.dirname(checkpoint_path)

# Create a callback that saves the model's weights
cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_path,
                                                 save_weights_only=True,
                                                 verbose=1)

# Fit your model to the training data for 200 epochs
#we assign this to history variable so we can plot the training data
history = model.fit(X_train,y_train,epochs=50, validation_split=0.2, callbacks=[cp_callback])

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('loss function')
plt.ylabel('mse')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

model.save('NYCPedestrianPrediction.h5')

# Evaluate your model accuracy on the test data
loss_test = model.evaluate(X_test,y_test)

# Print accuracy
print('mse_test:', loss_test)

ped_predict = model.predict(X_test)

print(X_test[140,:])



print(X_test)

print(scalerX.inverse_transform(X_test))

print(ped_predict)

y_pred = scalerY.inverse_transform(model.predict(X_test))
y_truth = scalerY.inverse_transform(y_test)

print(y_pred)

print(y_truth)

def plot_comparison(x_val, pred, truth, xlab, ylab): # define a plot function that we are creating for this scrip
  fig, ax1 = plt.subplots()
  ax1.plot(x_val, truth, color = "red", label = "truth",linestyle='None', marker = "o", markersize = 5)
  ax1.plot(x_val, pred, color = "blue", label = "pred",linestyle='None', marker = "o", markersize = 4, alpha = 0.5)

  ax1.set_xlabel(xlab)
  ax1.set_ylabel(ylab)
  ax1.legend()
  fig.set_figheight(10)
  fig.set_figwidth(20)
  plt.title('Prediction Comparison')
  plt.show()

trainstations = (scalerX.inverse_transform(X_test)[:,5])
amenities = (scalerX.inverse_transform(X_test)[:,4])


#X_test = (scalerX.inverse_transform(X_test)[:,2])
plot_comparison(trainstations, y_pred, y_truth, "Train Stations", "Pedestrian Totals")
plot_comparison(amenities, y_pred, y_truth,  "Amenities", "Pedestrian Totals")

"""Specify Location of Frozen files

# Savng Model for Unity Barracuda
"""

#path of the directory where you want to save your model
frozen_out_path = '/content/gdrive/MyDrive/Studio'
# name of the .pb file
frozen_graph_filename = 'frozen_graph'

# Convert Keras model to ConcreteFunction
full_model = tf.function(lambda x: model(x))
full_model = full_model.get_concrete_function(
    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))

# Get frozen graph def
frozen_func = convert_variables_to_constants_v2(full_model)
frozen_func.graph.as_graph_def()

layers = [op.name for op in frozen_func.graph.get_operations()]
print("-" * 60)
print("Frozen model layers: ")
for layer in layers:
    print(layer)
print("-" * 60)
print("Frozen model inputs: ")
print(frozen_func.inputs)
print("Frozen model outputs: ")
print(frozen_func.outputs)

tf.io.write_graph(graph_or_graph_def=frozen_func.graph,
                  logdir=frozen_out_path,
                  name=f"{frozen_graph_filename}.pb",
                  as_text=False)
tf.io.write_graph(graph_or_graph_def=frozen_func.graph,
                  logdir=frozen_out_path,
                  name=f"{frozen_graph_filename}.pbtxt",
                  as_text=True)

print("-" * 60)
print("Frozen model inputs: ")
print(frozen_func.inputs)
print("Frozen model outputs: ")
print(frozen_func.outputs)

#Convert frozen graph(*.pb) to ONNX for Unity
python -m tf2onnx.convert --graphdef frozen_graph.pb --inputs=input:0 --outputs=output:0 --output model.onnx